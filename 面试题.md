<!--
 * @Author: “Gavin” “850680822@qq.com”
 * @Date: 2022-12-14 15:04:26
 * @LastEditors: GAtomis
 * @LastEditTime: 2023-02-03 14:23:33
 * @FilePath: /workspace/threejs-init-react/面试题.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
### 面试题

HTTP和HTTPS区别
http
* 80
* 超文本传输协议
* tcp/ip
* 无状态
* 明文传输

url从回车到网页发生了什么
浏览器输入url地址-> 浏览器根据url封装为请求报文->请求报文发送到服务器端->服务器端对请求报文进行解析获取path,参数等信息->服务器端进行资源的查询->服务器端将前端需要的资源封装为响应报文-> 浏览器接收响应报文->浏览器进行解析

首先客户端浏览器发起http请求，然后服务器接收到请求，给出一个页面，浏览器接收到响应的html页面后，首先加载html页面，然后解析html代码，发现有外部css或者js引入后，开始加载外部css或者js，然后解析外部css或者js，最终将css与html代码绑定生成DOM树，然后渲染到浏览器中。
https
* 443
* 通过ssl和公钥和私钥进行加密
* 提高传输安全性
    
# CSS flex布局
* flex-grow 等分空间
* flex-basic 提前划分100px固定长度

## 页面上消失元素
* display：none
* visibility：hidden
* opacity：0
* 设置height、width模型属性为0
* position：absolute
* clip-path

## BFC
* overflow: hidden
* display: inline-block
* position: absolute
* position: fixed
* display: table-cell
* display: flex


移动端响应式布局
* rem 1rem = font-size 根据移动设备屏幕
* vw 

## 跨域
* 从ajax一个域名到另一个域名
* JSONP 请举起
* 请求头加headers

vue 优化
代码
* 响应式数据不要嵌套太深
* 不需要的数据不让要放在data里
* keepalive 缓存组件减少静态资源和回流重绘成本
* 防抖和截流
* 异步加载路由
* v-if v-show场景使用
* watch和computed区别使用
* v-for遍历加Key
* v-if和v-for不能同时使用
* 庞大数据进行分页数据处理
webpack
* 图片压缩
* 分场景转码 是否适用于es6
* 优化sou 
* sourcemap 关闭
* babel添加
* cdn引用
基础web优化
* 开启gzip联合nginx

缓存
强缓存:强缓存是利用http头中的Expires和Cache-Control两个字段来控制的，Expires是http1.0的规范，Cache-Control是在http1.1中出现的，我们这里使用Cache-Control示范。
协商缓存:Etag/If-None-Match返回的是一个校验码。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。
当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。



vite: 是什么一个前端构建平台
vite:插件=>生成钩子函数和创建钩子函数

```
//下面钩子每次有请求模块时都会被调用
//命中hooks
resolveId(){
    if(source==="virtual-module"){
        return source //命中
    }
    return null //继续处理
    
    
}
//读取处理 创建自定义函数 常用于定位第三方依赖
load(id){
        if(id ==="virtual-module"){
            return await import("./*.ts")
    }
    return null 
}
//可用于转换已加载的模块内容
transform(){
}
**//下面钩子会在服务器启动时调用

//替换或操作rollup 选项
options(){


}
//开始创建
buildStart(){

}
// 下面钩子会在服务器关闭时调用一次
buildEnd(){

}
closeBundle(){
    
}
 
``` 



前端架构设计

### 1.1 核心思想
* 解决问题：前端架构的设计，应是用于解决已存在或者未来可能发生的技术问题，增加项目的可管理性、稳定性、可扩展性。
* 人效比：对于需要额外开发工作量的事务（本文中存在一些需要一定开发量的内容），我们在决定是否去做的时候，应该考虑到两个要素：第一个是花费的人力成本，第二个是未来可能节约的时间和金钱、避免的项目风险与资损、提高对业务的支撑能力以带来在业务上可衡量的更高的价值、以及其他价值。
* 安全收益 ：衡量带来的收益或减少的成本
* 大数据收录：先确保项目中设计使用2.7里的埋点系统，根据埋点系统获取的数据,百度统计埋点

### 1.2 分层思考
基础建设层==>开发者
应用层==>组件设计和交互提示,错误提示

## 基础建设
### 2.1 自建Gitlab
这个是基础的基础了。本不应该提的，不过考虑到我最近面试的几家公司，有的公司（人数并不少）并没有使用Gitlab，因此专门提一下，并且使用这个的难度非常低。
强烈建议使用Gitlab进行版本管理，自建Gitlab难度并不大，方便管理，包括代码管理、权限管理、提交日志查询，以及联动一些第三方插件。
意义：
公司代码是公司的重要资产，使用自建Gitlab可以有效保护公司资产。

### 2.2 版本管理
版本管理的几个关键点：  
发布后分支锁死，不可再更改：指当例如0.0.1版本成功发布后，不可再更改0.0.1分支上的代码，否则可能会导致版本管理混乱。
全自动流程发布；指应避免开发者提交后，手动编译打包等操作，换句话说，开发人员发布后，将自动发布到预发布/生产环境。开发人员不和相关环境直接接触。实现这个需要参考下面的2.3。
多版本并存；指当例如发布0.0.2版本后，0.0.1版本的代码应仍保存在线上（例如CDN），这样当出现线上bug时，方便快速回滚到上一个版本。
意义：
提高项目的可控性。
### 2.3 自动编译发布Jenkins

### 2.4 脚手架统一管理
适用场景：有比较多独立中小项目。好处：

    
        可以减少开发人员配置脚手架带来的时间损耗（特殊功能可以fork脚手架后再自行定制）；
    
    
        统一项目结构，方便管理，也降低项目交接时带来的需要熟悉项目的时间；
    
    
        方便统一技术栈，可以预先引入固定的组件库；
    

意义：
提高开发人员在多个项目之间的快速切换能力，提高项目可维护性，统一公司技术栈，避免因为环境不同导致奇怪的问题。

### 2.5 多功能项目整合monreport

### 2.6 SSR技术优化SEO

### 2.7 埋点的价值

  *  记录每个页面的访问量（日周月年的UV、PV）；
  *  记录每个功能的使用量；
  *  捕捉报错情况；
  *  图表化显示，方便给其他部门展示；
  可以通过埋点监控报警

### 2.8 代码规范
Eslint和commotlint
### 2.9 合理静态资源引用
对cdn建设,杜绝使用不健康的第三方cdn 如jsdr 360cdn等

### 2.10 前后端分离和主备服务器

## 应用层设计
### 3.1 MPA和SPA的选择

多页面开发优势:颗粒度小 更新发版比较容易比较适合做公众号,广告 导购活动宣传,有利于seo,bug定位准确,版本控制相对简单
缺点:切换页面有白页,开发和维护成本较相对较大 
### 3.2 组件库建设
对有特殊性场景需求时,去开发 少于10人团队建议使用开源组件库去二次开发
* 使用ts开发
* 有单元测试
* 有自动化cli保证代码工程一致性
* 使用文档同步内容
* 版本隔离，小版本优化加功能，大改需要大版本更新；


### 3.3 技术栈权衡
根据团队技术风格偏向选择合适的技术栈
好处是人员较低调配成本, 避免重复造轮子

### 3.4 浏览器兼容
随着IE11不在维护,绝大多数互联网浏览器产品根据TC39制定的ECMA去开发浏览器
配置postcss，让某些css增加兼容性前缀；
写一个wepback的loader，处理某些特殊场景；
规范团队代码，使用更稳定的写法（例如移动端避免使用fixed进行布局）；

### 3.5 团队内文档
 